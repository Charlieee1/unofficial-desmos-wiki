---
title: Guide to 3D
eleventyNavigation:
  title: Guide to 3D
  parent: Main
  key: Guide to 3D
tags:
  - 3d
  - guide
layout: base.liquid
crosslinks: []
---

Making something 3D in Desmos may initially seem like a daunting task. However, it's ultimately far simpler than it looks once you break it down. This guide will explain how Desmos 3D works and how one can implement their own 3D engine. The focus will be on readability rather than achieving maximum performance.

## What are 3D Scenes Made Of?

Before diving into making an actual 3D engine, it's important to consider what 3D scenes are actually made of. 3D scenes are usually made up of 3D _meshes_. 3D meshes are nothing more than a group of many, many triangles in 3D space. These triangles are themselves made up of the following components:

1. A collection of 3D {% latex "\\left(x, y, z\\right)" %} points, where each point is called a _vertex_. Keep in mind that these will have to be split into three lists (a list of x-values, a list of y-values, and a list of z-values), because Desmos currently does not support 3D points.
2. A collection of numbers that determine _which_ points make up the vertices of _which_ triangles. For instance, these may say that a triangle in a mesh is formed from the 3rd, 4th, and 7th vertex. These numbers are called _indices_.

## A 2D Example

To better understand the concept of a mesh, here is a 2D analog of a mesh, where 2D vertices are being linked together into triangles to create a square:
{% desmos %}

settings @{
viewport: @{ xmin: -2, ymin: -2, xmax: 2, ymax: 2 },
};

points = [(0, 0), (1, 0), (1, 1), (0, 1)];
indicesP1 = [1, 2];
indicesP2 = [2, 3];
indicesP3 = [4, 4];

polygon(points[indicesP1], points[indicesP2], points[indicesP3])
{% enddesmos %}

In this case, we have a unit square with one corner at {% mq '(0, 0)' %} and another at {% mq '(1, 1)' %}. The first triangle is made up of the 1st, 2nd, and 4th vertices, while the second triangle is made up of the 2nd, 3rd, and 4th vertices.

You might notice the seemingly strange choice to use three lists for the indices ({% mq 'indicesP1' %}, {% mq 'indicesP2' %}, and {% mq 'indicesP3' %}). Using three index lists makes indexing easier because each triangle uses three indices. If we interleaved them all in a single list {% mq '[1, 2, 4, 2, 3, 4]' %} then we'd have to do slow, annoying indexing math to untangle the triangles' indices.

## How do we make this 3D?

How can we expand this to 3D? As stated earlier, we'll need to represent the 3D vertices as three different lists (just to be clear, these are different from the three index lists I just described). We'll need a list for the X-coordinates, one for the Y-coordinates, and a third for Z. Let's pick the vertices for a cube, where one corner is at {% latex "\\left(-1,-1,-5\\right)"%} and the other is at {% latex "\\left(1,1,-7\\right)"%}.

{% desmos '{ "graphpaper": false }'%}

XVertexPositions = [-1, 1, -1, 1, -1, 1, -1, 1];
YVertexPositions = [-1, -1, 1, 1, -1, -1, 1, 1];
ZVertexPositions = [-5, -5, -5, -5, -7, -7, -7, -7];

{% enddesmos %}

To actually render this, we'll need to convert these vertices from 3D coordinates to 2D coordinates, and then render them with the same technique we used to render the 2D square in the section above.

### Projection

"Projection" in this case refers to the process of converting _coordinates in 3D space_ to _2D coordinates on the screen_. We'll use a perspective projection, which is the same kind of projection that you use to see.

In a perspective projection, things appear smaller the farther they are away from the camera. How much smaller? Compare this to your own eyesight&mdash; if you have an object 1 meter away from your eyes, and then you move it so that it's 2 meters away, it appears half as large. If you move it 3 meters away, it appears one-third as large. If you move it 4 meters away, it appears one-fourth as large. Also note that the further away it gets, the closer it appears to the "center" of your field of vision.

In other words, the apparent size&mdash; and proximity to your field of view's center&mdash; is _inversely proportional_ to the depth of an object. This formalizes the intuition of farther away things being smaller.

### A Short Note on Coordinate Systems

For this guide, we'll be using a Y-up, Right-Handed coordinate system. By "Y-up" we mean that the Y-axis is the "up" direction, and by "Right-Handed" we mean that the coordinate system follows the right-hand rule: Positive X is right, positive Y is up, and positive Z is toward the camera. This is why all the Z-values in the cube are negative&mdash; we want it to be _in front of_ the camera so it displays properly.

### Putting it all together

So, given all this, since positive Z is forward and negative Z is backward, we can perform a perspective projection&mdash; converting from 3D to 2D, in other words&mdash; **by taking the X and Y components and dividing them by the negative of the Z component**. If we do this, we get the vertices of a cube:

{% desmos %}

settings @{
viewport: @{ xmin: -2, ymin: -2, xmax: 2, ymax: 2 },
};

XVertexPositions = [-1, 1, -1, 1, -1, 1, -1, 1];
YVertexPositions = [-1, -1, 1, 1, -1, -1, 1, 1];
ZVertexPositions = [-5, -5, -5, -5, -7, -7, -7, -7];

ScreenSpacePoints = (XVertexPositions, YVertexPositions) / -ZVertexPositions;

{% enddesmos %}

### Adding the Indices and Polygons

Now that we've got a bunch of 2D points, we can now get the indices of the 12 triangles that make up the 6 square faces of the cube and join them together with polygons, exactly like we did before with the 2D square:

{% desmos %}

settings @{
viewport: @{ xmin: -2, ymin: -2, xmax: 2, ymax: 2 },
};

XVertexPositions = [-1, 1, -1, 1, -1, 1, -1, 1];
YVertexPositions = [-1, -1, 1, 1, -1, -1, 1, 1];
ZVertexPositions = [-5, -5, -5, -5, -7, -7, -7, -7];

ScreenSpacePoints = (XVertexPositions, YVertexPositions) / -ZVertexPositions;

IndicesP1 = [1, 2, 3, 7, 1, 2, 1, 5, 2, 6, 5, 6];
IndicesP2 = [2, 4, 7, 4, 2, 5, 5, 3, 4, 4, 6, 8];
IndicesP3 = [3, 3, 4, 8, 5, 6, 3, 7, 6, 8, 7, 7];

polygon(ScreenSpacePoints[IndicesP1], ScreenSpacePoints[IndicesP2], ScreenSpacePoints[IndicesP3])

{% enddesmos %}
